<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fsharp on VGALTES blog</title>
    <link>http://example.org/categories/fsharp/</link>
    <description>Recent content in Fsharp on VGALTES blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 01 Apr 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://example.org/categories/fsharp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>A simple Azure Function using F#</title>
      <link>http://example.org/post/a-simple-azure-function-using-f-sharp/</link>
      <pubDate>Sat, 01 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/a-simple-azure-function-using-f-sharp/</guid>
      <description>The other day my friend Jero wrote an article explaining how to write a Google Function using Javascript. The goal of this article is to do the same exercise but using Azure Functions and F#.
First steps First of all, you will need to set up a couple of things. Don&amp;rsquo;t worry, both of them are free. First of all you&amp;rsquo;ll need an Azure account. You can create one for free and have Â£150 credit (and you&amp;rsquo;re not going to spend a single pound doing this exercise).</description>
    </item>
    
    <item>
      <title>Partial classification active pattern</title>
      <link>http://example.org/post/partial-classification-active-pattern/</link>
      <pubDate>Mon, 17 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/partial-classification-active-pattern/</guid>
      <description>Pattern matching is a powerful and amazing characteristic of F#. Actually, is so amazing that Microsoft is starting to port it to C#.
There are different kinds of pattern matching. In this post we&amp;rsquo;re going to take a look at a partial classification active pattern that takes an argument and returns a value.
As its name denotes, is a pattern that partially classificates what you match with it. That means that doesn&amp;rsquo;t try to define all possible options but just one.</description>
    </item>
    
    <item>
      <title>Running NUnit3 tests using fake</title>
      <link>http://example.org/post/run-nunit3-tests-using-fake/</link>
      <pubDate>Thu, 13 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/run-nunit3-tests-using-fake/</guid>
      <description>When you have some unit tests developed using NUnit 2.x your FAKE script looks like something like this:
Target &amp;quot;RunUnitTests&amp;quot; (fun _ -&amp;gt; !! (testDir + &amp;quot;/*.Tests.dll&amp;quot;) |&amp;gt; NUnit (fun p -&amp;gt; {p with ToolPath = &amp;quot;packages/NUnit.Runners/tools/&amp;quot;})  )
But NUnit3 works slightly different. Instead of having a single NUnit.Runners package, that package references some other packages (runner, extensions, etc). One of those packages is NUnit.ConsoleRunner that has the exe inside the tools folder.</description>
    </item>
    
    <item>
      <title>A Premier League team will win the Champions League this year</title>
      <link>http://example.org/post/a-premier-league-team-will-win-the-champions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/a-premier-league-team-will-win-the-champions/</guid>
      <description>Spain and Germany are dominating with an iron fist last Champions League editions. After a lot of investment, a Premier League team is ready to conquer the longed for trophy. In this article we&amp;rsquo;ll demonstrate this fact.
The data We&amp;rsquo;ve borrowed the data for this study from the UEFA&amp;rsquo;s official page. If you go to this address http://www.uefa.com/uefachampionsleague/season=2011/matches/all/index.html# you&amp;rsquo;ll see all the matches played in the season 2010&amp;frasl;2011. Change the year in the query string to see another year&amp;rsquo;s results.</description>
    </item>
    
    <item>
      <title>Arrays in F#</title>
      <link>http://example.org/post/arrays-in-fsharp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/arrays-in-fsharp/</guid>
      <description>Arrays are one of the basic data structures in F#. In this article we&amp;rsquo;re going to see an introduction of what can we do with them.
Creation There are several ways to create an array in F#
Create from a literal We can create an array with a predefined set of values. To do that, we just need to specify the values separated by semicolons and wrapped between [| and |]</description>
    </item>
    
    <item>
      <title>Decorator pattern in F#</title>
      <link>http://example.org/post/decorator-pattern-in-fsharp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/decorator-pattern-in-fsharp/</guid>
      <description>Introduction A couple of weeks ago my friend Ian Russell explained the decorator pattern at work. For those who don&amp;rsquo;t know exactly how it works, the decorator pattern allows us to add behavior to an individual object without affecting the behavior of other objects of that class (Wikipedia).
The object oriented solution There are a couple of typical implementations of the pattern in C#. The &amp;ldquo;lightweight&amp;rdquo; version is &amp;ldquo;just&amp;rdquo; to create decorators implementing the same interface of the decorated class, and passing the decorated object in the constructor of the decorator.</description>
    </item>
    
    <item>
      <title>Function composition and pipeline operator</title>
      <link>http://example.org/post/function-composition-and-pipeline-operator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/function-composition-and-pipeline-operator/</guid>
      <description>As Scott Wlaschin points out in his excellent article function composition it&amp;rsquo;s not the same as using the pipeline operator.
The definition of the pipeline operator is this one:
let (|&amp;gt;) x f = f x  So, take the thing on the left hand side of the operator and use it as the last parameter on the function in the right hand side.
On the other hand, we have this definition for the forward composition operator (&amp;gt;&amp;gt;)</description>
    </item>
    
    <item>
      <title>Sequences in F#</title>
      <link>http://example.org/post/sequences-in-fsharp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/sequences-in-fsharp/</guid>
      <description>A sequence is a list of potential values (all of them of the same type) computed on demand.
Sequence creation As with arrays there are several ways to create a sequence.
Create from a range expression
You can create a new sequence from a range expression. In this case, instead of using [| and |] you should use { and }
let numbers = {1..20}  Create from a sequence expression</description>
    </item>
    
  </channel>
</rss>